"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

"Reflects sequences of changes necessary to accurately calculate aggregate statistics\nsuch as volume, TVL and fees collected\n"
type AggEvent {
  askTick: Int
  baseFlow: BigInt
  bidTick: Int
  block: BigInt!
  eventIndex: Int!
  feeRate: Int
  flowsAtMarket: Boolean!
  id: Bytes!
  inBaseQty: Boolean!
  isFeeChange: Boolean!
  isLiq: Boolean!
  isSwap: Boolean!
  isTickSkewed: Boolean!
  pool: Pool!
  quoteFlow: BigInt
  swapPrice: BigDecimal
  time: BigInt!
  transactionHash: Bytes!
}

input AggEvent_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  askTick: Int
  askTick_gt: Int
  askTick_gte: Int
  askTick_in: [Int!]
  askTick_lt: Int
  askTick_lte: Int
  askTick_not: Int
  askTick_not_in: [Int!]
  baseFlow: BigInt
  baseFlow_gt: BigInt
  baseFlow_gte: BigInt
  baseFlow_in: [BigInt!]
  baseFlow_lt: BigInt
  baseFlow_lte: BigInt
  baseFlow_not: BigInt
  baseFlow_not_in: [BigInt!]
  bidTick: Int
  bidTick_gt: Int
  bidTick_gte: Int
  bidTick_in: [Int!]
  bidTick_lt: Int
  bidTick_lte: Int
  bidTick_not: Int
  bidTick_not_in: [Int!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  feeRate: Int
  feeRate_gt: Int
  feeRate_gte: Int
  feeRate_in: [Int!]
  feeRate_lt: Int
  feeRate_lte: Int
  feeRate_not: Int
  feeRate_not_in: [Int!]
  flowsAtMarket: Boolean
  flowsAtMarket_in: [Boolean!]
  flowsAtMarket_not: Boolean
  flowsAtMarket_not_in: [Boolean!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  inBaseQty: Boolean
  inBaseQty_in: [Boolean!]
  inBaseQty_not: Boolean
  inBaseQty_not_in: [Boolean!]
  isFeeChange: Boolean
  isFeeChange_in: [Boolean!]
  isFeeChange_not: Boolean
  isFeeChange_not_in: [Boolean!]
  isLiq: Boolean
  isLiq_in: [Boolean!]
  isLiq_not: Boolean
  isLiq_not_in: [Boolean!]
  isSwap: Boolean
  isSwap_in: [Boolean!]
  isSwap_not: Boolean
  isSwap_not_in: [Boolean!]
  isTickSkewed: Boolean
  isTickSkewed_in: [Boolean!]
  isTickSkewed_not: Boolean
  isTickSkewed_not_in: [Boolean!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  quoteFlow: BigInt
  quoteFlow_gt: BigInt
  quoteFlow_gte: BigInt
  quoteFlow_in: [BigInt!]
  quoteFlow_lt: BigInt
  quoteFlow_lte: BigInt
  quoteFlow_not: BigInt
  quoteFlow_not_in: [BigInt!]
  swapPrice: BigDecimal
  swapPrice_gt: BigDecimal
  swapPrice_gte: BigDecimal
  swapPrice_in: [BigDecimal!]
  swapPrice_lt: BigDecimal
  swapPrice_lte: BigDecimal
  swapPrice_not: BigDecimal
  swapPrice_not_in: [BigDecimal!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum AggEvent_orderBy {
  askTick
  baseFlow
  bidTick
  block
  eventIndex
  feeRate
  flowsAtMarket
  id
  inBaseQty
  isFeeChange
  isLiq
  isSwap
  isTickSkewed
  pool
  quoteFlow
  swapPrice
  time
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

"A FeeChange represents an update to the swap fee setting on a given SdexSwap\nliquidity pool.\n"
type FeeChange {
  block: BigInt!
  callIndex: Int!
  feeRate: Int!
  id: Bytes!
  pool: Pool!
  time: BigInt!
  transactionHash: Bytes!
}

input FeeChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  callIndex: Int
  callIndex_gt: Int
  callIndex_gte: Int
  callIndex_in: [Int!]
  callIndex_lt: Int
  callIndex_lte: Int
  callIndex_not: Int
  callIndex_not_in: [Int!]
  feeRate: Int
  feeRate_gt: Int
  feeRate_gte: Int
  feeRate_in: [Int!]
  feeRate_lt: Int
  feeRate_lte: Int
  feeRate_not: Int
  feeRate_not_in: [Int!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum FeeChange_orderBy {
  block
  callIndex
  feeRate
  id
  pool
  time
  transactionHash
}

"A KnockoutCross is an exact copy of the data emitted in a KnockoutCross event\nemitted by the SdexSwap DEX. There is an exact 1:1 correspondence between\nemitted events and KnockoutCross entities created by the subgraph.\n"
type KnockoutCross {
  block: BigInt!
  feeMileage: BigInt!
  id: Bytes!
  isBid: Boolean!
  pivotTime: BigInt!
  pool: Pool!
  tick: Int!
  time: BigInt!
  transactionHash: Bytes!
}

input KnockoutCross_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  feeMileage: BigInt
  feeMileage_gt: BigInt
  feeMileage_gte: BigInt
  feeMileage_in: [BigInt!]
  feeMileage_lt: BigInt
  feeMileage_lte: BigInt
  feeMileage_not: BigInt
  feeMileage_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  isBid: Boolean
  isBid_in: [Boolean!]
  isBid_not: Boolean
  isBid_not_in: [Boolean!]
  pivotTime: BigInt
  pivotTime_gt: BigInt
  pivotTime_gte: BigInt
  pivotTime_in: [BigInt!]
  pivotTime_lt: BigInt
  pivotTime_lte: BigInt
  pivotTime_not: BigInt
  pivotTime_not_in: [BigInt!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  tick: Int
  tick_gt: Int
  tick_gte: Int
  tick_in: [Int!]
  tick_lt: Int
  tick_lte: Int
  tick_not: Int
  tick_not_in: [Int!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum KnockoutCross_orderBy {
  block
  feeMileage
  id
  isBid
  pivotTime
  pool
  tick
  time
  transactionHash
}

"LatestIndex entities are used to help perform bookkeeping related to the\ngeneration of unique event IDs in the case where multiple identical entities\nwould otherwise be created within the same transaction.\n"
type LatestIndex {
  callIndex: Int!
  id: Bytes!
}

input LatestIndex_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  callIndex: Int
  callIndex_gt: Int
  callIndex_gte: Int
  callIndex_in: [Int!]
  callIndex_lt: Int
  callIndex_lte: Int
  callIndex_not: Int
  callIndex_not_in: [Int!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
}

enum LatestIndex_orderBy {
  callIndex
  id
}

"A LiquidityChange entity represents a single modification to a single\nliquidity position made on SdexSwap. LiquidityChanges are categorized\naccording to their changeType, which can be equal to mint, burn, harvest,\nclaim, or recover.\n"
type LiquidityChange {
  askTick: Int
  baseFlow: BigInt
  bidTick: Int
  block: BigInt!
  callIndex: Int!
  callSource: String!
  changeType: String!
  id: Bytes!
  isBid: Boolean!
  liq: BigInt
  pivotTime: BigInt
  pool: Pool!
  positionType: String!
  quoteFlow: BigInt
  time: BigInt!
  transactionHash: Bytes!
  user: Bytes!
}

input LiquidityChange_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  askTick: Int
  askTick_gt: Int
  askTick_gte: Int
  askTick_in: [Int!]
  askTick_lt: Int
  askTick_lte: Int
  askTick_not: Int
  askTick_not_in: [Int!]
  baseFlow: BigInt
  baseFlow_gt: BigInt
  baseFlow_gte: BigInt
  baseFlow_in: [BigInt!]
  baseFlow_lt: BigInt
  baseFlow_lte: BigInt
  baseFlow_not: BigInt
  baseFlow_not_in: [BigInt!]
  bidTick: Int
  bidTick_gt: Int
  bidTick_gte: Int
  bidTick_in: [Int!]
  bidTick_lt: Int
  bidTick_lte: Int
  bidTick_not: Int
  bidTick_not_in: [Int!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  callIndex: Int
  callIndex_gt: Int
  callIndex_gte: Int
  callIndex_in: [Int!]
  callIndex_lt: Int
  callIndex_lte: Int
  callIndex_not: Int
  callIndex_not_in: [Int!]
  callSource: String
  callSource_contains: String
  callSource_contains_nocase: String
  callSource_ends_with: String
  callSource_ends_with_nocase: String
  callSource_gt: String
  callSource_gte: String
  callSource_in: [String!]
  callSource_lt: String
  callSource_lte: String
  callSource_not: String
  callSource_not_contains: String
  callSource_not_contains_nocase: String
  callSource_not_ends_with: String
  callSource_not_ends_with_nocase: String
  callSource_not_in: [String!]
  callSource_not_starts_with: String
  callSource_not_starts_with_nocase: String
  callSource_starts_with: String
  callSource_starts_with_nocase: String
  changeType: String
  changeType_contains: String
  changeType_contains_nocase: String
  changeType_ends_with: String
  changeType_ends_with_nocase: String
  changeType_gt: String
  changeType_gte: String
  changeType_in: [String!]
  changeType_lt: String
  changeType_lte: String
  changeType_not: String
  changeType_not_contains: String
  changeType_not_contains_nocase: String
  changeType_not_ends_with: String
  changeType_not_ends_with_nocase: String
  changeType_not_in: [String!]
  changeType_not_starts_with: String
  changeType_not_starts_with_nocase: String
  changeType_starts_with: String
  changeType_starts_with_nocase: String
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  isBid: Boolean
  isBid_in: [Boolean!]
  isBid_not: Boolean
  isBid_not_in: [Boolean!]
  liq: BigInt
  liq_gt: BigInt
  liq_gte: BigInt
  liq_in: [BigInt!]
  liq_lt: BigInt
  liq_lte: BigInt
  liq_not: BigInt
  liq_not_in: [BigInt!]
  pivotTime: BigInt
  pivotTime_gt: BigInt
  pivotTime_gte: BigInt
  pivotTime_in: [BigInt!]
  pivotTime_lt: BigInt
  pivotTime_lte: BigInt
  pivotTime_not: BigInt
  pivotTime_not_in: [BigInt!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  positionType: String
  positionType_contains: String
  positionType_contains_nocase: String
  positionType_ends_with: String
  positionType_ends_with_nocase: String
  positionType_gt: String
  positionType_gte: String
  positionType_in: [String!]
  positionType_lt: String
  positionType_lte: String
  positionType_not: String
  positionType_not_contains: String
  positionType_not_contains_nocase: String
  positionType_not_ends_with: String
  positionType_not_ends_with_nocase: String
  positionType_not_in: [String!]
  positionType_not_starts_with: String
  positionType_not_starts_with_nocase: String
  positionType_starts_with: String
  positionType_starts_with_nocase: String
  quoteFlow: BigInt
  quoteFlow_gt: BigInt
  quoteFlow_gte: BigInt
  quoteFlow_in: [BigInt!]
  quoteFlow_lt: BigInt
  quoteFlow_lte: BigInt
  quoteFlow_not: BigInt
  quoteFlow_not_in: [BigInt!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum LiquidityChange_orderBy {
  askTick
  baseFlow
  bidTick
  block
  callIndex
  callSource
  changeType
  id
  isBid
  liq
  pivotTime
  pool
  positionType
  quoteFlow
  time
  transactionHash
  user
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

"A Pool represents a single liquidity pool on SdexSwap, which is uniquely\nspecified by a base token, a quote token, and a poolIdx. The ID of the Pool\nis the same as the poolHash used internally in SdexSwap contracts.\n"
type Pool {
  base: Bytes!
  blockCreate: BigInt!
  id: Bytes!
  liquidityChanges(
    first: Int = 100
    orderBy: LiquidityChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityChange_filter
  ): [LiquidityChange!]!
  poolIdx: BigInt!
  quote: Bytes!
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]!
  template: PoolTemplate
  timeCreate: BigInt!
}

"PoolTemplate represents a pool type pattern to create new pools\n"
type PoolTemplate {
  blockInit: BigInt!
  blockRevise: BigInt!
  enabled: Boolean!
  feeRate: Int!
  id: Bytes!
  poolIdx: BigInt!
  pools(
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Pool_filter
  ): [Pool!]!
  timeInit: BigInt!
  timeRevise: BigInt!
}

input PoolTemplate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  blockInit: BigInt
  blockInit_gt: BigInt
  blockInit_gte: BigInt
  blockInit_in: [BigInt!]
  blockInit_lt: BigInt
  blockInit_lte: BigInt
  blockInit_not: BigInt
  blockInit_not_in: [BigInt!]
  blockRevise: BigInt
  blockRevise_gt: BigInt
  blockRevise_gte: BigInt
  blockRevise_in: [BigInt!]
  blockRevise_lt: BigInt
  blockRevise_lte: BigInt
  blockRevise_not: BigInt
  blockRevise_not_in: [BigInt!]
  enabled: Boolean
  enabled_in: [Boolean!]
  enabled_not: Boolean
  enabled_not_in: [Boolean!]
  feeRate: Int
  feeRate_gt: Int
  feeRate_gte: Int
  feeRate_in: [Int!]
  feeRate_lt: Int
  feeRate_lte: Int
  feeRate_not: Int
  feeRate_not_in: [Int!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  poolIdx: BigInt
  poolIdx_gt: BigInt
  poolIdx_gte: BigInt
  poolIdx_in: [BigInt!]
  poolIdx_lt: BigInt
  poolIdx_lte: BigInt
  poolIdx_not: BigInt
  poolIdx_not_in: [BigInt!]
  pools_: Pool_filter
  timeInit: BigInt
  timeInit_gt: BigInt
  timeInit_gte: BigInt
  timeInit_in: [BigInt!]
  timeInit_lt: BigInt
  timeInit_lte: BigInt
  timeInit_not: BigInt
  timeInit_not_in: [BigInt!]
  timeRevise: BigInt
  timeRevise_gt: BigInt
  timeRevise_gte: BigInt
  timeRevise_in: [BigInt!]
  timeRevise_lt: BigInt
  timeRevise_lte: BigInt
  timeRevise_not: BigInt
  timeRevise_not_in: [BigInt!]
}

enum PoolTemplate_orderBy {
  blockInit
  blockRevise
  enabled
  feeRate
  id
  poolIdx
  pools
  timeInit
  timeRevise
}

input Pool_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  base: Bytes
  base_contains: Bytes
  base_in: [Bytes!]
  base_not: Bytes
  base_not_contains: Bytes
  base_not_in: [Bytes!]
  blockCreate: BigInt
  blockCreate_gt: BigInt
  blockCreate_gte: BigInt
  blockCreate_in: [BigInt!]
  blockCreate_lt: BigInt
  blockCreate_lte: BigInt
  blockCreate_not: BigInt
  blockCreate_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  liquidityChanges_: LiquidityChange_filter
  poolIdx: BigInt
  poolIdx_gt: BigInt
  poolIdx_gte: BigInt
  poolIdx_in: [BigInt!]
  poolIdx_lt: BigInt
  poolIdx_lte: BigInt
  poolIdx_not: BigInt
  poolIdx_not_in: [BigInt!]
  quote: Bytes
  quote_contains: Bytes
  quote_in: [Bytes!]
  quote_not: Bytes
  quote_not_contains: Bytes
  quote_not_in: [Bytes!]
  swaps_: Swap_filter
  template: String
  template_: PoolTemplate_filter
  template_contains: String
  template_contains_nocase: String
  template_ends_with: String
  template_ends_with_nocase: String
  template_gt: String
  template_gte: String
  template_in: [String!]
  template_lt: String
  template_lte: String
  template_not: String
  template_not_contains: String
  template_not_contains_nocase: String
  template_not_ends_with: String
  template_not_ends_with_nocase: String
  template_not_in: [String!]
  template_not_starts_with: String
  template_not_starts_with_nocase: String
  template_starts_with: String
  template_starts_with_nocase: String
  timeCreate: BigInt
  timeCreate_gt: BigInt
  timeCreate_gte: BigInt
  timeCreate_in: [BigInt!]
  timeCreate_lt: BigInt
  timeCreate_lte: BigInt
  timeCreate_not: BigInt
  timeCreate_not_in: [BigInt!]
}

enum Pool_orderBy {
  base
  blockCreate
  id
  liquidityChanges
  poolIdx
  quote
  swaps
  template
  timeCreate
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  aggEvent(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AggEvent
  aggEvents(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AggEvent_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AggEvent_filter
  ): [AggEvent!]!
  feeChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeChange
  feeChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeChange_filter
  ): [FeeChange!]!
  knockoutCross(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): KnockoutCross
  knockoutCrosses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: KnockoutCross_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: KnockoutCross_filter
  ): [KnockoutCross!]!
  latestIndex(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestIndex
  latestIndexes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestIndex_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestIndex_filter
  ): [LatestIndex!]!
  liquidityChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityChange
  liquidityChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityChange_filter
  ): [LiquidityChange!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolTemplate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolTemplate
  poolTemplates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolTemplate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolTemplate_filter
  ): [PoolTemplate!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  userBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserBalance
  userBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserBalance_filter
  ): [UserBalance!]!
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  aggEvent(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AggEvent
  aggEvents(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AggEvent_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AggEvent_filter
  ): [AggEvent!]!
  feeChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeChange
  feeChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeChange_filter
  ): [FeeChange!]!
  knockoutCross(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): KnockoutCross
  knockoutCrosses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: KnockoutCross_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: KnockoutCross_filter
  ): [KnockoutCross!]!
  latestIndex(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestIndex
  latestIndexes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestIndex_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestIndex_filter
  ): [LatestIndex!]!
  liquidityChange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityChange
  liquidityChanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityChange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityChange_filter
  ): [LiquidityChange!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolTemplate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolTemplate
  poolTemplates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolTemplate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolTemplate_filter
  ): [PoolTemplate!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  userBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserBalance
  userBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserBalance_filter
  ): [UserBalance!]!
}

"A Swap entity represents an atomic swap of a base token for a quote token\nmade on either SdexSwap or Uniswap V3.\n"
type Swap {
  baseFlow: BigInt!
  block: BigInt!
  callIndex: Int!
  callSource: String!
  dex: String!
  id: Bytes!
  inBaseQty: Boolean!
  isBuy: Boolean!
  limitPrice: BigDecimal
  minOut: BigInt
  pool: Pool!
  price: BigDecimal
  qty: BigInt!
  quoteFlow: BigInt!
  time: BigInt!
  transactionHash: Bytes!
  transactionIndex: BigInt!
  user: Bytes!
}

input Swap_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  baseFlow: BigInt
  baseFlow_gt: BigInt
  baseFlow_gte: BigInt
  baseFlow_in: [BigInt!]
  baseFlow_lt: BigInt
  baseFlow_lte: BigInt
  baseFlow_not: BigInt
  baseFlow_not_in: [BigInt!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  callIndex: Int
  callIndex_gt: Int
  callIndex_gte: Int
  callIndex_in: [Int!]
  callIndex_lt: Int
  callIndex_lte: Int
  callIndex_not: Int
  callIndex_not_in: [Int!]
  callSource: String
  callSource_contains: String
  callSource_contains_nocase: String
  callSource_ends_with: String
  callSource_ends_with_nocase: String
  callSource_gt: String
  callSource_gte: String
  callSource_in: [String!]
  callSource_lt: String
  callSource_lte: String
  callSource_not: String
  callSource_not_contains: String
  callSource_not_contains_nocase: String
  callSource_not_ends_with: String
  callSource_not_ends_with_nocase: String
  callSource_not_in: [String!]
  callSource_not_starts_with: String
  callSource_not_starts_with_nocase: String
  callSource_starts_with: String
  callSource_starts_with_nocase: String
  dex: String
  dex_contains: String
  dex_contains_nocase: String
  dex_ends_with: String
  dex_ends_with_nocase: String
  dex_gt: String
  dex_gte: String
  dex_in: [String!]
  dex_lt: String
  dex_lte: String
  dex_not: String
  dex_not_contains: String
  dex_not_contains_nocase: String
  dex_not_ends_with: String
  dex_not_ends_with_nocase: String
  dex_not_in: [String!]
  dex_not_starts_with: String
  dex_not_starts_with_nocase: String
  dex_starts_with: String
  dex_starts_with_nocase: String
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  inBaseQty: Boolean
  inBaseQty_in: [Boolean!]
  inBaseQty_not: Boolean
  inBaseQty_not_in: [Boolean!]
  isBuy: Boolean
  isBuy_in: [Boolean!]
  isBuy_not: Boolean
  isBuy_not_in: [Boolean!]
  limitPrice: BigDecimal
  limitPrice_gt: BigDecimal
  limitPrice_gte: BigDecimal
  limitPrice_in: [BigDecimal!]
  limitPrice_lt: BigDecimal
  limitPrice_lte: BigDecimal
  limitPrice_not: BigDecimal
  limitPrice_not_in: [BigDecimal!]
  minOut: BigInt
  minOut_gt: BigInt
  minOut_gte: BigInt
  minOut_in: [BigInt!]
  minOut_lt: BigInt
  minOut_lte: BigInt
  minOut_not: BigInt
  minOut_not_in: [BigInt!]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  qty: BigInt
  qty_gt: BigInt
  qty_gte: BigInt
  qty_in: [BigInt!]
  qty_lt: BigInt
  qty_lte: BigInt
  qty_not: BigInt
  qty_not_in: [BigInt!]
  quoteFlow: BigInt
  quoteFlow_gt: BigInt
  quoteFlow_gte: BigInt
  quoteFlow_in: [BigInt!]
  quoteFlow_lt: BigInt
  quoteFlow_lte: BigInt
  quoteFlow_not: BigInt
  quoteFlow_not_in: [BigInt!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transactionIndex: BigInt
  transactionIndex_gt: BigInt
  transactionIndex_gte: BigInt
  transactionIndex_in: [BigInt!]
  transactionIndex_lt: BigInt
  transactionIndex_lte: BigInt
  transactionIndex_not: BigInt
  transactionIndex_not_in: [BigInt!]
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum Swap_orderBy {
  baseFlow
  block
  callIndex
  callSource
  dex
  id
  inBaseQty
  isBuy
  limitPrice
  minOut
  pool
  price
  qty
  quoteFlow
  time
  transactionHash
  transactionIndex
  user
}

"A UserBalance entity represents the first time that a user might have\nconceivably \"received\" a given token from the SdexSwap DEX, such as via\nthe output of a swap or via the burning of a liquidity position. These\nentities collectively represent the universe of tokens for which users\nmight have nonzero internal DEX balances.\n"
type UserBalance {
  block: BigInt!
  id: Bytes!
  time: BigInt!
  token: Bytes!
  transactionHash: Bytes!
  user: Bytes!
}

input UserBalance_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_in: [Bytes!]
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  time: BigInt
  time_gt: BigInt
  time_gte: BigInt
  time_in: [BigInt!]
  time_lt: BigInt
  time_lte: BigInt
  time_not: BigInt
  time_not_in: [BigInt!]
  token: Bytes
  token_contains: Bytes
  token_in: [Bytes!]
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  user: Bytes
  user_contains: Bytes
  user_in: [Bytes!]
  user_not: Bytes
  user_not_contains: Bytes
  user_not_in: [Bytes!]
}

enum UserBalance_orderBy {
  block
  id
  time
  token
  transactionHash
  user
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
