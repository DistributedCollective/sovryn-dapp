"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type BAsset {
  decimals: Int
  id: ID!
  name: String
  symbol: String
}

input BAsset_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
}

enum BAsset_orderBy {
  decimals
  id
  name
  symbol
}

type BassetAdded {
  basset: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  transactionHash: Bytes!
}

input BassetAdded_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  basset: Bytes
  basset_contains: Bytes
  basset_in: [Bytes!]
  basset_not: Bytes
  basset_not_contains: Bytes
  basset_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum BassetAdded_orderBy {
  basset
  blockNumber
  blockTimestamp
  emittedBy
  id
  timestamp
  transaction
  transactionHash
}

type BassetRemoved {
  basset: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  emittedBy: Bytes!
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  transactionHash: Bytes!
}

input BassetRemoved_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  basset: Bytes
  basset_contains: Bytes
  basset_in: [Bytes!]
  basset_not: Bytes
  basset_not_contains: Bytes
  basset_not_in: [Bytes!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum BassetRemoved_orderBy {
  basset
  blockNumber
  blockTimestamp
  emittedBy
  id
  timestamp
  transaction
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Conversion {
  bAsset: BAsset!
  bassetQuantity: BigDecimal!
  emittedBy: Bytes!
  id: ID!
  massetQuantity: BigDecimal!
  recipient: Bytes!
  timestamp: Int!
  transaction: Transaction!
  type: ConversionType!
  user: User!
}

enum ConversionType {
  Incoming
  Outgoing
}

input Conversion_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bAsset: String
  bAsset_: BAsset_filter
  bAsset_contains: String
  bAsset_contains_nocase: String
  bAsset_ends_with: String
  bAsset_ends_with_nocase: String
  bAsset_gt: String
  bAsset_gte: String
  bAsset_in: [String!]
  bAsset_lt: String
  bAsset_lte: String
  bAsset_not: String
  bAsset_not_contains: String
  bAsset_not_contains_nocase: String
  bAsset_not_ends_with: String
  bAsset_not_ends_with_nocase: String
  bAsset_not_in: [String!]
  bAsset_not_starts_with: String
  bAsset_not_starts_with_nocase: String
  bAsset_starts_with: String
  bAsset_starts_with_nocase: String
  bassetQuantity: BigDecimal
  bassetQuantity_gt: BigDecimal
  bassetQuantity_gte: BigDecimal
  bassetQuantity_in: [BigDecimal!]
  bassetQuantity_lt: BigDecimal
  bassetQuantity_lte: BigDecimal
  bassetQuantity_not: BigDecimal
  bassetQuantity_not_in: [BigDecimal!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  massetQuantity: BigDecimal
  massetQuantity_gt: BigDecimal
  massetQuantity_gte: BigDecimal
  massetQuantity_in: [BigDecimal!]
  massetQuantity_lt: BigDecimal
  massetQuantity_lte: BigDecimal
  massetQuantity_not: BigDecimal
  massetQuantity_not_in: [BigDecimal!]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_in: [Bytes!]
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  type: ConversionType
  type_in: [ConversionType!]
  type_not: ConversionType
  type_not_in: [ConversionType!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum Conversion_orderBy {
  bAsset
  bassetQuantity
  emittedBy
  id
  massetQuantity
  recipient
  timestamp
  transaction
  type
  user
}

type Minted {
  bAsset: Bytes!
  bassetQuantity: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  emittedBy: Bytes!
  id: ID!
  massetQuantity: BigInt!
  minter: Bytes!
  recipient: Bytes!
  timestamp: Int!
  transaction: Transaction!
  transactionHash: Bytes!
}

input Minted_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bAsset: Bytes
  bAsset_contains: Bytes
  bAsset_in: [Bytes!]
  bAsset_not: Bytes
  bAsset_not_contains: Bytes
  bAsset_not_in: [Bytes!]
  bassetQuantity: BigInt
  bassetQuantity_gt: BigInt
  bassetQuantity_gte: BigInt
  bassetQuantity_in: [BigInt!]
  bassetQuantity_lt: BigInt
  bassetQuantity_lte: BigInt
  bassetQuantity_not: BigInt
  bassetQuantity_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  massetQuantity: BigInt
  massetQuantity_gt: BigInt
  massetQuantity_gte: BigInt
  massetQuantity_in: [BigInt!]
  massetQuantity_lt: BigInt
  massetQuantity_lte: BigInt
  massetQuantity_not: BigInt
  massetQuantity_not_in: [BigInt!]
  minter: Bytes
  minter_contains: Bytes
  minter_in: [Bytes!]
  minter_not: Bytes
  minter_not_contains: Bytes
  minter_not_in: [Bytes!]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_in: [Bytes!]
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Minted_orderBy {
  bAsset
  bassetQuantity
  blockNumber
  blockTimestamp
  emittedBy
  id
  massetQuantity
  minter
  recipient
  timestamp
  transaction
  transactionHash
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  basset(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAsset
  bassetAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BassetAdded
  bassetAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BassetAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BassetAdded_filter
  ): [BassetAdded!]!
  bassetRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BassetRemoved
  bassetRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BassetRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BassetRemoved_filter
  ): [BassetRemoved!]!
  bassets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAsset_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAsset_filter
  ): [BAsset!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  minted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Minted
  minteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Minted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Minted_filter
  ): [Minted!]!
  redeemed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Redeemed
  redeemeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Redeemed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Redeemed_filter
  ): [Redeemed!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Redeemed {
  bAsset: Bytes!
  bassetQuantity: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  emittedBy: Bytes!
  id: ID!
  massetQuantity: BigInt!
  recipient: Bytes!
  redeemer: Bytes!
  timestamp: Int!
  transaction: Transaction!
  transactionHash: Bytes!
}

input Redeemed_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  bAsset: Bytes
  bAsset_contains: Bytes
  bAsset_in: [Bytes!]
  bAsset_not: Bytes
  bAsset_not_contains: Bytes
  bAsset_not_in: [Bytes!]
  bassetQuantity: BigInt
  bassetQuantity_gt: BigInt
  bassetQuantity_gte: BigInt
  bassetQuantity_in: [BigInt!]
  bassetQuantity_lt: BigInt
  bassetQuantity_lte: BigInt
  bassetQuantity_not: BigInt
  bassetQuantity_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_contains: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not: Bytes
  emittedBy_not_contains: Bytes
  emittedBy_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  massetQuantity: BigInt
  massetQuantity_gt: BigInt
  massetQuantity_gte: BigInt
  massetQuantity_in: [BigInt!]
  massetQuantity_lt: BigInt
  massetQuantity_lte: BigInt
  massetQuantity_not: BigInt
  massetQuantity_not_in: [BigInt!]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_in: [Bytes!]
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  redeemer: Bytes
  redeemer_contains: Bytes
  redeemer_in: [Bytes!]
  redeemer_not: Bytes
  redeemer_not_contains: Bytes
  redeemer_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  transaction: String
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Redeemed_orderBy {
  bAsset
  bassetQuantity
  blockNumber
  blockTimestamp
  emittedBy
  id
  massetQuantity
  recipient
  redeemer
  timestamp
  transaction
  transactionHash
}

type Subscription {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
  basset(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BAsset
  bassetAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BassetAdded
  bassetAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BassetAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BassetAdded_filter
  ): [BassetAdded!]!
  bassetRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BassetRemoved
  bassetRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BassetRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BassetRemoved_filter
  ): [BassetRemoved!]!
  bassets(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BAsset_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BAsset_filter
  ): [BAsset!]!
  conversion(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Conversion_filter
  ): [Conversion!]!
  minted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Minted
  minteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Minted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Minted_filter
  ): [Minted!]!
  redeemed(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Redeemed
  redeemeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Redeemed_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Redeemed_filter
  ): [Redeemed!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Transaction {
  blockNumber: Int!

  "The account that initiated this transaction. This must be an Account and not a Contract.\n"
  from: User!
  functionSignature: String!
  gasLimit: BigInt!
  gasPrice: BigInt!
  gasUsed: BigInt

  """
  Transaction hash
  """
  id: ID!

  "The index of this transaction within the block\n"
  index: Int!

  "The timestamp the transaction was confirmed\n"
  timestamp: Int!

  "The contract the user interacted with\n"
  to: Bytes
  value: BigInt!
}

input Transaction_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  blockNumber: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_in: [Int!]
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_not: Int
  blockNumber_not_in: [Int!]
  from: String
  from_: User_filter
  from_contains: String
  from_contains_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_gt: String
  from_gte: String
  from_in: [String!]
  from_lt: String
  from_lte: String
  from_not: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_not_in: [String!]
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  functionSignature: String
  functionSignature_contains: String
  functionSignature_contains_nocase: String
  functionSignature_ends_with: String
  functionSignature_ends_with_nocase: String
  functionSignature_gt: String
  functionSignature_gte: String
  functionSignature_in: [String!]
  functionSignature_lt: String
  functionSignature_lte: String
  functionSignature_not: String
  functionSignature_not_contains: String
  functionSignature_not_contains_nocase: String
  functionSignature_not_ends_with: String
  functionSignature_not_ends_with_nocase: String
  functionSignature_not_in: [String!]
  functionSignature_not_starts_with: String
  functionSignature_not_starts_with_nocase: String
  functionSignature_starts_with: String
  functionSignature_starts_with_nocase: String
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_gt: BigInt
  gasUsed_gte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_lt: BigInt
  gasUsed_lte: BigInt
  gasUsed_not: BigInt
  gasUsed_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  to: Bytes
  to_contains: Bytes
  to_in: [Bytes!]
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  from
  functionSignature
  gasLimit
  gasPrice
  gasUsed
  id
  index
  timestamp
  to
  value
}

type User {
  createdAt: Int!
  id: ID!
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  createdAt: Int
  createdAt_gt: Int
  createdAt_gte: Int
  createdAt_in: [Int!]
  createdAt_lt: Int
  createdAt_lte: Int
  createdAt_not: Int
  createdAt_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
}

enum User_orderBy {
  createdAt
  id
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
