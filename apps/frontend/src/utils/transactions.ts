import { JsonRpcSigner } from '@ethersproject/providers';
import {
  PERMIT2_ADDRESS,
  PermitTransferFrom,
  SignatureTransfer,
  MaxAllowanceTransferAmount,
} from '@uniswap/permit2-sdk';

import dayjs, { ManipulateType } from 'dayjs';
import { BigNumber, BigNumberish, constants, ethers } from 'ethers';
import { t } from 'i18next';

import { getAssetData } from '@sovryn/contracts';
import { ChainId } from '@sovryn/ethers-provider';
import {
  PermitTransactionResponse,
  TypedDataTransactionRequest,
  prepareERC2612Permit,
} from '@sovryn/sdk';
import { Decimal } from '@sovryn/utils';

import { RSK_CHAIN_ID } from '../config/chains';

import {
  Transaction,
  TransactionReceipt,
  TransactionReceiptStatus,
  TransactionRequest,
  TransactionType,
} from '../app/3_organisms/TransactionStepDialog/TransactionStepDialog.types';
import { APPROVAL_FUNCTION } from '../constants/general';
import { translations } from '../locales/i18n';
import { COMMON_SYMBOLS, findAsset, findAssetByAddress } from './asset';
import { generateNonce } from './helpers';

export const prepareDeadline = (
  value: number = 1,
  unit: ManipulateType = 'hour',
) => dayjs().add(value, unit).unix();

export const UNSIGNED_PERMIT = {
  deadline: 0,
  v: 0,
  r: constants.HashZero,
  s: constants.HashZero,
} as PermitTransactionResponse;

export const EMPTY_PERMIT_TRANSFER_FROM = {
  permitted: {
    token: constants.AddressZero,
    amount: Decimal.ONE.toString(),
  },
  spender: constants.AddressZero,
  nonce: 0,
  deadline: prepareDeadline(30, 'days'),
} as PermitTransferFrom;

// This signature was generated by doing a sample transaction, it doesn't contain any sensitive information
export const DEFAULT_SIGNATURE =
  '0x86638c772f972d496f6671bc8157498b853ef064f134e813ddd25269c6a01a385ed8032201f3b91a84b46d75bb3ea50c919a576927975bab5b91829833eb8e111c';

type PreparePermitTransactionOptions = {
  token: string;
  signer: JsonRpcSigner;
  spender: string;
  value?: string;
  deadline?: number;
  nonce?: number;
  chain?: ChainId;
};

/**
 * @deprecated Use prepareTypedDataTransaction instead
 */
export const preparePermitTransaction = async ({
  token = COMMON_SYMBOLS.DLLR,
  chain = RSK_CHAIN_ID,
  signer,
  spender,
  value,
  deadline = prepareDeadline(),
  nonce,
}: PreparePermitTransactionOptions): Promise<Transaction> => {
  const { address: tokenAddress, symbol } = findAsset(token, chain);
  const { domain, types, values } = await prepareERC2612Permit(
    signer.provider,
    tokenAddress,
    await signer.getAddress(),
    spender,
    value,
    deadline,
    nonce,
  );
  return {
    title: t(translations.common.tx.signPermitTitle, {
      symbol,
    }),
    subtitle: t(translations.common.tx.signPermitSubtitle, {
      symbol,
    }),
    request: {
      type: TransactionType.signTypedData,
      signer,
      domain,
      types,
      values,
    },
  };
};

export const preparePermit2Transaction = async (
  permit: PermitTransferFrom,
  signer: JsonRpcSigner,
): Promise<Transaction> => {
  const { domain, types, values } = SignatureTransfer.getPermitData(
    permit,
    PERMIT2_ADDRESS,
    parseInt(RSK_CHAIN_ID),
  );

  const { symbol } = findAsset(COMMON_SYMBOLS.DLLR, RSK_CHAIN_ID);

  return {
    title: t(translations.common.tx.signPermitTitle, {
      symbol,
    }),
    subtitle: t(translations.common.tx.signPermitSubtitle, {
      symbol,
    }),
    request: {
      type: TransactionType.signTypedData,
      domain,
      types,
      values: values,
      signer,
    },
  };
};

const getTokenAddressInTypedData = ({
  domain,
  values,
}: TypedDataTransactionRequest['typedData']) => {
  // Permit2
  if (values?.permitted?.token) {
    return values.permitted.token;
  }

  // Permit
  if (domain?.verifyingContract) {
    return domain.verifyingContract;
  }

  return undefined;
};

export const prepareTypedDataTransaction = async (
  { typedData }: TypedDataTransactionRequest,
  signer: JsonRpcSigner,
  chainId = RSK_CHAIN_ID,
): Promise<Transaction> => {
  const tokenAddress = getTokenAddressInTypedData(typedData);
  const symbol = tokenAddress
    ? findAssetByAddress(tokenAddress, chainId)?.symbol
    : undefined;

  return {
    title: t(translations.common.tx.signPermitTitle, {
      symbol,
    }),
    subtitle: t(translations.common.tx.signPermitSubtitle, {
      symbol,
    }),
    request: {
      type: TransactionType.signTypedData,
      domain: typedData.domain,
      types: typedData.types,
      values: typedData.values,
      signer,
    },
  };
};

export const getPermitTransferFrom = async (
  spender: string,
  amount: string,
  token = COMMON_SYMBOLS.DLLR,
): Promise<PermitTransferFrom> => {
  const { address: tokenAddress } = findAsset(token, RSK_CHAIN_ID);

  const nonce = generateNonce();

  const permitTransferFrom: PermitTransferFrom = {
    permitted: {
      token: tokenAddress,
      amount,
    },
    spender,
    nonce,
    deadline: prepareDeadline(30, 'days'),
  };

  return permitTransferFrom;
};

type PrepareApproveTransactionOptions = {
  token: string;
  chain?: ChainId;
  spender: string;
  amount?: BigNumberish;
  signer?: JsonRpcSigner;
  contract?: ethers.Contract;
  approveMaximumAmount?: boolean;
};

export const prepareApproveTransaction = async ({
  token = COMMON_SYMBOLS.DLLR,
  chain = RSK_CHAIN_ID,
  spender,
  amount = '0',
  signer,
  contract,
  approveMaximumAmount = false,
}: PrepareApproveTransactionOptions): Promise<Transaction | undefined> => {
  const loadTokenContract = async () => {
    if (contract) {
      return contract;
    } else if (signer) {
      const { contract } = await getAssetData(token, chain);
      return contract(signer);
    }

    throw new Error('signer or contract must provided, but not both.');
  };

  const tokenContract = await loadTokenContract();
  const owner = await tokenContract.signer.getAddress();

  const allowance = await tokenContract.allowance(owner, spender);
  const symbol =
    findAsset(token, chain)?.symbol ?? findAssetByAddress(token, chain)?.symbol;

  if (BigNumber.from(allowance).lt(amount)) {
    return {
      title: t(translations.common.tx.signApproveTitle, {
        symbol,
      }),
      subtitle: t(translations.common.tx.signApproveSubtitle, {
        symbol,
      }),
      request: {
        type: TransactionType.signTransaction,
        contract: tokenContract,
        fnName: APPROVAL_FUNCTION,
        args: [
          spender,
          approveMaximumAmount ? MaxAllowanceTransferAmount : amount,
        ],
      },
    };
  }
};

export const permitHandler =
  (
    override: (
      req: TransactionRequest,
      res: string | PermitTransactionResponse | undefined,
    ) => TransactionRequest | Promise<TransactionRequest>,
    permitIndex: number = 0,
  ) =>
  (request: TransactionRequest, receipts: TransactionReceipt[]) => {
    if (
      receipts.length &&
      receipts[permitIndex]?.status === TransactionReceiptStatus.success &&
      (receipts[permitIndex]?.request.type === TransactionType.signPermit ||
        receipts[permitIndex]?.request.type === TransactionType.signTypedData)
    ) {
      return override(request, receipts[permitIndex].response);
    }

    return request;
  };
